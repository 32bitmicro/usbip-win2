/*
 * Copyright (C) 2022 Vadym Hrynchyshyn <vadimgrn@gmail.com>
 */

#include <ntifs.h>

#include "device.h"
#include "trace.h"
#include "device.tmh"

#include "driver.h"

#include <wdmsec.h>
#include <initguid.h>

namespace
{

using namespace usbip;

DEFINE_GUID(GUID_SD_USBIP2_FILTER,
	0x8d7b540b, 0x77f8, 0x4942, 0x92, 0x8c, 0x77, 0xa9, 0x7a, 0xa1, 0x96, 0x40);

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
PAGED auto init(_Inout_ filter_ext &f, _In_opt_ filter_ext *parent)
{
	PAGED_CODE();
	NT_ASSERT(f.is_hub == !parent);

	IoInitializeRemoveLock(&f.remove_lock, pooltag, 0, 0);

	if (f.is_hub) {
		//
	} else if (auto lck = &parent->remove_lock; auto err = IoAcquireRemoveLock(lck, 0)) {
		Trace(TRACE_LEVEL_ERROR, "Acquire remove lock %!STATUS!", err);
		return err;
	} else {
		f.dev.parent_remove_lock = lck;
	}

	return STATUS_SUCCESS;
}

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
PAGED void do_destroy(_Inout_ filter_ext &f)
{
	PAGED_CODE();

	if (f.is_hub) {
		auto &hub = f.hub;
		if (auto &ptr = hub.previous) {
			ExFreePoolWithTag(ptr, pooltag);
			ptr = nullptr;
		}
	} else {
		auto &dev = f.dev;
		if (auto &ptr = dev.parent_remove_lock) {
			IoReleaseRemoveLock(ptr, 0);
			ptr = nullptr;
		}
	}
}

/*
 * DRIVER_OBJECT.DriverName is an undocumented member and can't be used.
 */
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
PAGED bool driver_name_equal(
	_In_ DRIVER_OBJECT *driver, _In_ const UNICODE_STRING &expected, _In_ bool CaseInSensitive)
{
	PAGED_CODE();

	buffer buf(POOL_FLAG_PAGED | POOL_FLAG_UNINITIALIZED, 1024);
	if (!buf) {
		Trace(TRACE_LEVEL_ERROR, "Cannot allocate %Iu bytes", buf.size());
		return false;
	}

	auto info = buf.get<OBJECT_NAME_INFORMATION>();

	ULONG actual_sz;
	if (auto err = ObQueryNameString(driver, info, ULONG(buf.size()), &actual_sz)) {
		Trace(TRACE_LEVEL_ERROR, "ObQueryNameString %!STATUS!", err);
		return false;
	}

	TraceDbg("DriverName '%!USTR!'", &info->Name);
	return RtlEqualUnicodeString(&info->Name, &expected, CaseInSensitive);
}

/*
 * Do not check that HardwareID is "USB\ROOT_HUB30" because above usbip2_vhci can be nothing else.
 * 
 * for (auto cur = IoGetAttachedDeviceReference(pdo); cur; ) { // @see IoGetDeviceAttachmentBaseRef
 * 	auto lower = IoGetLowerDeviceObject(cur);
 *	ObDereferenceObject(cur);
 *	cur = lower;
 * }
 */
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
PAGED auto is_abobe_vhci(_In_ DEVICE_OBJECT *pdo)
{
	PAGED_CODE();

	DECLARE_CONST_UNICODE_STRING(vhci, L"\\Driver\\usbip2_vhci"); // FIXME: declare in header?
	return driver_name_equal(pdo->DriverObject, vhci, true);
}

} // namespace


_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
PAGED void* usbip::GetDeviceProperty(
	_In_ DEVICE_OBJECT *devobj, _In_ DEVICE_REGISTRY_PROPERTY prop, 
	_Inout_ NTSTATUS &error, _Inout_ ULONG &ResultLength)
{
	PAGED_CODE();

	if (!ResultLength) {
		ResultLength = 1024;
	}
	
	auto alloc = [] (auto len) { return ExAllocatePool2(POOL_FLAG_PAGED | POOL_FLAG_UNINITIALIZED, len, pooltag); };

	for (auto buf = alloc(ResultLength); buf; ) {

		error = IoGetDeviceProperty(devobj, prop, ResultLength, buf, &ResultLength);

		switch (error) {
		case STATUS_SUCCESS:
			return buf;
		case STATUS_BUFFER_TOO_SMALL:
			ExFreePoolWithTag(buf, pooltag);
			buf = alloc(ResultLength);
			break;
		default:
			TraceDbg("%!DEVICE_REGISTRY_PROPERTY! %!STATUS!", prop, error);
			ExFreePoolWithTag(buf, pooltag);
			return nullptr;
		}
	}

	error = STATUS_INSUFFICIENT_RESOURCES;
	return nullptr;
}

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
PAGED void usbip::destroy(_Inout_ filter_ext &f)
{
	PAGED_CODE();
	TraceDbg("FiDO %04x, pdo %04x, lower %04x", ptr04x(f.self), ptr04x(f.pdo), ptr04x(f.lower));

	if (auto &target = f.lower) {
		IoDetachDevice(target);
		target = nullptr;
	}

	do_destroy(f);
	IoDeleteDevice(f.self);
}

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_When_(return>=0, _Kernel_clear_do_init_(__yes))
PAGED NTSTATUS usbip::do_add_device(
	_In_ DRIVER_OBJECT *drvobj, _In_ DEVICE_OBJECT *pdo, _In_opt_ filter_ext *parent)
{
	PAGED_CODE();
	auto hub = !parent;

	auto type = hub ? FILE_DEVICE_UNKNOWN : pdo->DeviceType;
	const auto props = FILE_DEVICE_SECURE_OPEN | FILE_AUTOGENERATED_DEVICE_NAME;

	filter_ext *fltr{};
	DEVICE_OBJECT *fido{}; // Filter Device Object

	if (auto err = IoCreateDeviceSecure(drvobj, sizeof(*fltr), nullptr, type, props, false, 
		                            &SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RWX_RES_RWX,
		                            &GUID_SD_USBIP2_FILTER, &fido)) {
		Trace(TRACE_LEVEL_ERROR, "IoCreateDeviceSecure %!STATUS!", err);
		return err;
	}

	fltr = get_filter_ext(fido); 

	fltr->self = fido;
	fltr->pdo = pdo;
	fltr->is_hub = hub;

	if (auto err = init(*fltr, parent)) {
		destroy(*fltr);
		return err;
	}

	auto &lower = fltr->lower;

	lower = IoAttachDeviceToDeviceStack(fido, pdo);
	if (!lower) {
		auto err = STATUS_NO_SUCH_DEVICE;
		Trace(TRACE_LEVEL_ERROR, "IoAttachDeviceToDeviceStack %!STATUS!", err);
		destroy(*fltr);
		return err;
	}

	Trace(TRACE_LEVEL_INFORMATION, "FiDO %04x, PDO %04x, lower PDO %04x", 
		ptr04x(fido), ptr04x(pdo), ptr04x(lower));

	{
		auto &Flags = fido->Flags;
		Flags |= lower->Flags & (DO_BUFFERED_IO | DO_DIRECT_IO | DO_POWER_PAGABLE);
		Flags &= ~DO_DEVICE_INITIALIZING;
	}

	return STATUS_SUCCESS;
}

_Function_class_(DRIVER_ADD_DEVICE)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
PAGED NTSTATUS usbip::add_device(_In_ DRIVER_OBJECT *drvobj, _In_ DEVICE_OBJECT *hub_or_hci_pdo)
{
	PAGED_CODE();

	if (!is_abobe_vhci(hub_or_hci_pdo)) {
		TraceDbg("Skip this device");
		return STATUS_SUCCESS;
	}

	return do_add_device(drvobj, hub_or_hci_pdo, nullptr);
}
