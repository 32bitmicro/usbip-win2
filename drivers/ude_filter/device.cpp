/*
 * Copyright (C) 2022 Vadym Hrynchyshyn <vadimgrn@gmail.com>
 */

#include <ntifs.h>

#include "device.h"
#include "trace.h"
#include "device.tmh"

#include "irp.h"
#include "driver.h"

#include <wdmsec.h>
#include <initguid.h>

namespace
{

using namespace usbip;

DEFINE_GUID(GUID_SD_USBIP2_FILTER,
	0x8d7b540b, 0x77f8, 0x4942, 0x92, 0x8c, 0x77, 0xa9, 0x7a, 0xa1, 0x96, 0x40);

/*
 * DRIVER_OBJECT.DriverName is an undocumented member and can't be used.
 */
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
PAGED bool driver_name_equal(
	_In_ DRIVER_OBJECT *driver, _In_ const UNICODE_STRING &expected, _In_ bool CaseInSensitive)
{
	PAGED_CODE();

	buffer buf(POOL_FLAG_PAGED | POOL_FLAG_UNINITIALIZED, 1024);
	if (!buf) {
		Trace(TRACE_LEVEL_ERROR, "Cannot allocate %Iu bytes", buf.size());
		return false;
	}

	auto info = buf.get<OBJECT_NAME_INFORMATION>();

	ULONG actual_sz;
	if (auto err = ObQueryNameString(driver, info, ULONG(buf.size()), &actual_sz)) {
		Trace(TRACE_LEVEL_ERROR, "ObQueryNameString %!STATUS!", err);
		return false;
	}

	TraceDbg("DriverName '%!USTR!'", &info->Name);
	return RtlEqualUnicodeString(&info->Name, &expected, CaseInSensitive);
}

/*
 * Do not check that HardwareID is "USB\ROOT_HUB30" because above usbip2_vhci can be nothing else.
 * 
 * for (auto cur = IoGetAttachedDeviceReference(pdo); cur; ) { // @see IoGetDeviceAttachmentBaseRef
 * 	auto lower = IoGetLowerDeviceObject(cur);
 *	ObDereferenceObject(cur);
 *	cur = lower;
 * }
 */
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
PAGED auto is_abobe_vhci(_In_ DEVICE_OBJECT *pdo)
{
	PAGED_CODE();

	DECLARE_CONST_UNICODE_STRING(vhci, L"\\Driver\\usbip2_vhci"); // FIXME: declare in header?
	return driver_name_equal(pdo->DriverObject, vhci, true);
}

} // namespace


_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
PAGED void* usbip::GetDeviceProperty(
	_In_ DEVICE_OBJECT *devobj, _In_ DEVICE_REGISTRY_PROPERTY prop, 
	_Inout_ NTSTATUS &error, _Inout_ ULONG &ResultLength)
{
	PAGED_CODE();

	if (!ResultLength) {
		ResultLength = 1024;
	}
	
	auto alloc = [] (auto len) { return ExAllocatePool2(POOL_FLAG_PAGED | POOL_FLAG_UNINITIALIZED, len, pooltag); };

	for (auto buf = alloc(ResultLength); buf; ) {

		error = IoGetDeviceProperty(devobj, prop, ResultLength, buf, &ResultLength);

		switch (error) {
		case STATUS_SUCCESS:
			return buf;
		case STATUS_BUFFER_TOO_SMALL:
			ExFreePoolWithTag(buf, pooltag);
			buf = alloc(ResultLength);
			break;
		default:
			TraceDbg("%!DEVICE_REGISTRY_PROPERTY! %!STATUS!", prop, error);
			ExFreePoolWithTag(buf, pooltag);
			return nullptr;
		}
	}

	error = STATUS_INSUFFICIENT_RESOURCES;
	return nullptr;
}

_Function_class_(DRIVER_ADD_DEVICE)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
_When_(return>=0, _Kernel_clear_do_init_(__yes))
PAGED NTSTATUS usbip::add_device(_In_ DRIVER_OBJECT *drvobj, _In_ DEVICE_OBJECT *hub_or_hci_pdo)
{
        PAGED_CODE();

	if (!is_abobe_vhci(hub_or_hci_pdo)) {
		TraceDbg("Skip this device");
		return STATUS_SUCCESS;
	}
	
	const auto props = FILE_DEVICE_SECURE_OPEN | FILE_AUTOGENERATED_DEVICE_NAME;

	filter_ext *fltr{};
	DEVICE_OBJECT *fido{}; // Filter Device Object

	if (auto err = IoCreateDeviceSecure(drvobj, sizeof(*fltr), nullptr, FILE_DEVICE_UNKNOWN, props,
		                            false, &SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RWX_RES_RWX,
		                            &GUID_SD_USBIP2_FILTER, &fido)) {
		Trace(TRACE_LEVEL_ERROR, "IoCreateDeviceSecure %!STATUS!", err);
		return err;
	}

	fltr = get_filter_ext(fido); 

	fltr->self = fido;
//	fltr->pdo = hub_or_hci_pdo;
	auto &lower = fltr->lower;

	lower = IoAttachDeviceToDeviceStack(fido, hub_or_hci_pdo);
	if (!lower) {
		auto err = STATUS_NO_SUCH_DEVICE;
		Trace(TRACE_LEVEL_ERROR, "IoAttachDeviceToDeviceStack %!STATUS!", err);
		IoDeleteDevice(fido);
		return err;
	}

	{
		auto &Flags = fido->Flags;
		Flags |= lower->Flags & (DO_BUFFERED_IO | DO_DIRECT_IO | DO_POWER_PAGABLE);
		Flags &= ~DO_DEVICE_INITIALIZING;
	}

	Trace(TRACE_LEVEL_INFORMATION, "FiDO %04x, root_hub30 PDO %04x, lower PDO %04x", 
		ptr04x(fido), ptr04x(hub_or_hci_pdo), ptr04x(lower));

	return STATUS_SUCCESS;
}

_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
PAGED void usbip::destroy(_Inout_ filter_ext &fltr)
{
	PAGED_CODE();

	if (auto &target = fltr.lower) {
		IoDetachDevice(target);
		target = nullptr;
	}

	IoDeleteDevice(fltr.self);
}

_Function_class_(DRIVER_DISPATCH)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_same_
NTSTATUS usbip::dispatch_lower(_In_ DEVICE_OBJECT *devobj, _Inout_ IRP *irp)
{
	if (auto fltr = get_filter_ext(devobj); auto &lower = fltr->lower) {
		return ForwardIrpAsync(lower, irp);
	}

	auto err = STATUS_INVALID_DEVICE_REQUEST;
	auto &stack = *IoGetCurrentIrpStackLocation(irp);

	Trace(TRACE_LEVEL_ERROR, "MajorFunction %#x, MinorFunction %#x, %!STATUS!", 
		                  stack.MajorFunction, stack.MinorFunction, err);

	return CompleteRequest(irp, err);
}
