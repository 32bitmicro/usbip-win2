#include "vhci_dev.h"
#include "trace.h"
#include "vhci_dev.tmh"
#include "basetype.h"
#include "vhci.h"

#include <wdmsec.h>
#include <initguid.h> // required for GUID definitions

DEFINE_GUID(GUID_SD_USBIP_VHCI,
	0x9d3039dd, 0xcca5, 0x4b4d, 0xb3, 0x3d, 0xe2, 0xdd, 0xc8, 0xa8, 0xc5, 0x2f);

LPCWSTR devcodes[] = {
	L"ROOT", L"CPDO", L"VHCI", L"HPDO", L"VHUB", L"VPDO"
};

namespace
{

const ULONG ext_sizes_per_devtype[] = {
	sizeof(root_dev_t),
	sizeof(cpdo_dev_t),
	sizeof(vhci_dev_t),
	sizeof(hpdo_dev_t),
	sizeof(vhub_dev_t),
	sizeof(vpdo_dev_t)
};

} // namespace

LPWSTR get_device_prop(PDEVICE_OBJECT pdo, DEVICE_REGISTRY_PROPERTY prop, PULONG plen)
{
	ULONG buflen = 0;

	NTSTATUS status = IoGetDeviceProperty(pdo, prop, 0, nullptr, &buflen);
	if (status != STATUS_BUFFER_TOO_SMALL) {
		Trace(TRACE_LEVEL_ERROR, "failed to get device property size: %!STATUS!", status);
		return nullptr;
	}

	auto value = (LPWSTR)ExAllocatePoolWithTag(PagedPool, buflen, USBIP_VHCI_POOL_TAG);
	if (!value) {
		Trace(TRACE_LEVEL_ERROR, "failed to get device property: out of memory");
		return nullptr;
	}

	status = IoGetDeviceProperty(pdo, prop, buflen, value, &buflen);
	if (NT_ERROR(status)) {
		Trace(TRACE_LEVEL_ERROR, "failed to get device property: %!STATUS!", status);
		ExFreePoolWithTag(value, USBIP_VHCI_POOL_TAG);
		return nullptr;
	}
	if (plen != nullptr)
		*plen = buflen;
	return value;
}

PAGEABLE PDEVICE_OBJECT vdev_create(PDRIVER_OBJECT drvobj, vdev_type_t type)
{
	PAGED_CODE();

	DEVICE_OBJECT *devobj = nullptr;
	ULONG	extsize = ext_sizes_per_devtype[type];
	NTSTATUS status{};

	switch (type) {
	case VDEV_CPDO:
	case VDEV_HPDO:
	case VDEV_VPDO:
		status = IoCreateDeviceSecure(drvobj, extsize, nullptr,
			FILE_DEVICE_BUS_EXTENDER, FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
			FALSE, &SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RWX_RES_RWX, // allow normal users to access the devices
			(LPCGUID)&GUID_SD_USBIP_VHCI, &devobj);
		break;
	default:
		status = IoCreateDevice(drvobj, extsize, nullptr,
			FILE_DEVICE_BUS_EXTENDER, FILE_DEVICE_SECURE_OPEN, TRUE, &devobj);
	}

	if (!NT_SUCCESS(status)) {
		Trace(TRACE_LEVEL_ERROR, "failed to create vdev(%!vdev_type_t!): %!STATUS!", type, status);
		return nullptr;
	}

	auto vdev = devobj_to_vdev(devobj);
	RtlZeroMemory(vdev, extsize);

	vdev->DevicePnPState = NotStarted;
	vdev->PreviousPnPState = NotStarted;

	vdev->type = type;
	vdev->Self = devobj;

	vdev->DevicePowerState = PowerDeviceUnspecified;
	vdev->SystemPowerState = PowerSystemWorking;

	devobj->Flags |= DO_POWER_PAGABLE | DO_BUFFERED_IO;

	return devobj;
}

cpdo_dev_t *devobj_to_cpdo_or_null(DEVICE_OBJECT *devobj)
{
	auto vdev = devobj_to_vdev(devobj);
	NT_ASSERT(vdev);
	return vdev->type == VDEV_CPDO ? static_cast<cpdo_dev_t*>(vdev) : nullptr;
}

vhci_dev_t *devobj_to_vhci_or_null(DEVICE_OBJECT *devobj)
{
	auto vdev = devobj_to_vdev(devobj);
	NT_ASSERT(vdev);
	return vdev->type == VDEV_VHCI ? static_cast<vhci_dev_t*>(vdev) : nullptr;
}

hpdo_dev_t *devobj_to_hpdo_or_null(DEVICE_OBJECT *devobj)
{
	auto vdev = devobj_to_vdev(devobj);
	NT_ASSERT(vdev);
	return vdev->type == VDEV_HPDO ? static_cast<hpdo_dev_t*>(vdev) : nullptr;
}

vhub_dev_t *devobj_to_vhub_or_null(DEVICE_OBJECT *devobj)
{
	auto vdev = devobj_to_vdev(devobj);
	NT_ASSERT(vdev);
	return vdev->type == VDEV_VHUB ? static_cast<vhub_dev_t*>(vdev) : nullptr;
}

vpdo_dev_t *devobj_to_vpdo_or_null(DEVICE_OBJECT *devobj)
{
	auto vdev = devobj_to_vdev(devobj);
	NT_ASSERT(vdev);
	return vdev->type == VDEV_VPDO ? static_cast<vpdo_dev_t*>(vdev) : nullptr;
}
