#include "dev.h"
#include "trace.h"
#include "dev.tmh"
#include "pageable.h"
#include "vhci.h"
#include "irp.h"
#include "read.h"

#include <wdmsec.h>
#include <initguid.h> // required for GUID definitions

DEFINE_GUID(GUID_SD_USBIP_VHCI,
	0x9d3039dd, 0xcca5, 0x4b4d, 0xb3, 0x3d, 0xe2, 0xdd, 0xc8, 0xa8, 0xc5, 0x2f);

namespace
{

const ULONG ext_sizes_per_devtype[VDEV_SIZE] = 
{
	sizeof(root_dev_t),
	sizeof(cpdo_dev_t),
	sizeof(vhci_dev_t),
	sizeof(hpdo_dev_t),
	sizeof(vhub_dev_t),
	sizeof(vpdo_dev_t)
};

} // namespace


void *GetDeviceProperty(DEVICE_OBJECT *obj, DEVICE_REGISTRY_PROPERTY prop, NTSTATUS &error, ULONG &ResultLength)
{
	ResultLength = 256;
	auto alloc = [] (auto len) { return ExAllocatePoolWithTag(PagedPool, len, USBIP_VHCI_POOL_TAG); };

	for (auto buf = alloc(ResultLength); buf; ) {
		
		error = IoGetDeviceProperty(obj, prop, ResultLength, buf, &ResultLength);
		
		switch (error) {
		case STATUS_SUCCESS:
			return buf;
		case STATUS_BUFFER_TOO_SMALL:
			ExFreePoolWithTag(buf, USBIP_VHCI_POOL_TAG);
			buf = alloc(ResultLength);
			break;
		default:
			ExFreePoolWithTag(buf, USBIP_VHCI_POOL_TAG);
			return nullptr;
		}
	}

	error = USBD_STATUS_INSUFFICIENT_RESOURCES;
	return nullptr;
}

PAGEABLE PDEVICE_OBJECT vdev_create(DRIVER_OBJECT *drvobj, vdev_type_t type)
{
	PAGED_CODE();

	DEVICE_OBJECT *devobj{};
	auto extsize = ext_sizes_per_devtype[type];
	NTSTATUS status{};

	switch (type) {
	case VDEV_CPDO:
	case VDEV_HPDO:
	case VDEV_VPDO:
		status = IoCreateDeviceSecure(drvobj, extsize, nullptr,
				FILE_DEVICE_BUS_EXTENDER, FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
				FALSE, &SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RWX_RES_RWX, // allow normal users to access the devices
				&GUID_SD_USBIP_VHCI, &devobj);
		break;
	default:
		status = IoCreateDevice(drvobj, extsize, nullptr,
					FILE_DEVICE_BUS_EXTENDER, FILE_DEVICE_SECURE_OPEN, TRUE, &devobj);
	}

	if (!NT_SUCCESS(status)) {
		Trace(TRACE_LEVEL_ERROR, "Failed to create vdev(%!vdev_type_t!): %!STATUS!", type, status);
		return nullptr;
	}

	auto vdev = to_vdev(devobj);

	vdev->PnPState = pnp_state::NotStarted;
	vdev->PreviousPnPState = pnp_state::NotStarted;

	vdev->type = type;
	vdev->Self = devobj;

	vdev->DevicePowerState = PowerDeviceUnspecified;
	vdev->SystemPowerState = PowerSystemWorking;

	devobj->Flags |= DO_POWER_PAGABLE | DO_BUFFERED_IO;

	return devobj;
}

vhub_dev_t *vhub_from_vhci(vhci_dev_t *vhci)
{	
	NT_ASSERT(vhci);
	auto child_pdo = vhci->child_pdo;
	return child_pdo ? reinterpret_cast<vhub_dev_t*>(child_pdo->fdo) : nullptr;
}

cpdo_dev_t *to_cpdo_or_null(DEVICE_OBJECT *devobj)
{
	auto vdev = to_vdev(devobj);
	return vdev->type == VDEV_CPDO ? static_cast<cpdo_dev_t*>(vdev) : nullptr;
}

vhci_dev_t *to_vhci_or_null(DEVICE_OBJECT *devobj)
{
	auto vdev = to_vdev(devobj);
	return vdev->type == VDEV_VHCI ? static_cast<vhci_dev_t*>(vdev) : nullptr;
}

hpdo_dev_t *to_hpdo_or_null(DEVICE_OBJECT *devobj)
{
	auto vdev = to_vdev(devobj);
	return vdev->type == VDEV_HPDO ? static_cast<hpdo_dev_t*>(vdev) : nullptr;
}

vhub_dev_t *to_vhub_or_null(DEVICE_OBJECT *devobj)
{
	auto vdev = to_vdev(devobj);
	return vdev->type == VDEV_VHUB ? static_cast<vhub_dev_t*>(vdev) : nullptr;
}

vpdo_dev_t *to_vpdo_or_null(DEVICE_OBJECT *devobj)
{
	auto vdev = to_vdev(devobj);
	return vdev->type == VDEV_VPDO ? static_cast<vpdo_dev_t*>(vdev) : nullptr;
}

seqnum_t next_seqnum(vpdo_dev_t *vpdo)
{
	auto &val = vpdo->seqnum;
	return ++val ? val : ++val; // skip zero in case of overflow
}

void enqueue_canceled_irp(vpdo_dev_t *vpdo, IRP *irp, cancel_queue queue)
{
	NT_ASSERT(get_seqnum_unlink(irp));

	bool rx = queue == cancel_queue::rx;
	auto head = rx ? &vpdo->rx_canceled_irps : &vpdo->tx_canceled_irps;

	TraceCall("seqnum %u, irp %04x -> %s", get_seqnum(irp), irp4log(irp), rx ? "rx" : "tx");

	KLOCK_QUEUE_HANDLE qh;
	KeAcquireInStackQueuedSpinLock(&vpdo->canceled_irps_lock, &qh);
	InsertTailList(head, list_entry(irp));
	KeReleaseInStackQueuedSpinLock(&qh);
}

IRP *dequeue_canceled_irp(vpdo_dev_t *vpdo, cancel_queue queue, seqnum_t seqnum, bool unlink)
{
	IRP *irp{};
	bool rx = queue == cancel_queue::rx;
	auto head = rx ? &vpdo->rx_canceled_irps : &vpdo->tx_canceled_irps;
	auto func = unlink ? get_seqnum_unlink : get_seqnum;

	KLOCK_QUEUE_HANDLE qh;
	KeAcquireInStackQueuedSpinLock(&vpdo->canceled_irps_lock, &qh);		

	for (auto entry = head->Flink; entry != head; entry = entry->Flink) {

		auto entry_irp = get_irp(entry);
		
		if (!seqnum || seqnum == func(entry_irp)) {
			RemoveEntryList(entry);
			InitializeListHead(entry);
			irp = entry_irp;
			break;
		}
	}

	KeReleaseInStackQueuedSpinLock(&qh);

	TraceCall("%s(seqnum %u, unlink %d) -> irp %04x", rx ? "rx" : "tx", seqnum, unlink, irp4log(irp));
	return irp;
}

void clear_context(IRP *irp)
{
	set_seqnum(irp, 0);
	set_seqnum_unlink(irp, 0);
	set_pipe_handle(irp, USBD_PIPE_HANDLE());
}
