#include "dev.h"
#include "trace.h"
#include "dev.tmh"
#include "pageable.h"
#include "vhci.h"

#include <wdmsec.h>
#include <initguid.h> // required for GUID definitions

DEFINE_GUID(GUID_SD_USBIP_VHCI,
	0x9d3039dd, 0xcca5, 0x4b4d, 0xb3, 0x3d, 0xe2, 0xdd, 0xc8, 0xa8, 0xc5, 0x2f);

namespace
{

const ULONG ext_sizes_per_devtype[] = {
	sizeof(root_dev_t),
	sizeof(cpdo_dev_t),
	sizeof(vhci_dev_t),
	sizeof(hpdo_dev_t),
	sizeof(vhub_dev_t),
	sizeof(vpdo_dev_t)
};

} // namespace


LPWSTR get_device_prop(DEVICE_OBJECT *pdo, DEVICE_REGISTRY_PROPERTY prop, ULONG *plen)
{
	ULONG buflen = 0;

	auto status = IoGetDeviceProperty(pdo, prop, 0, nullptr, &buflen);
	if (status != STATUS_BUFFER_TOO_SMALL) {
		Trace(TRACE_LEVEL_ERROR, "IoGetDeviceProperty %!STATUS!", status);
		return nullptr;
	}

	if (plen) {
		*plen = buflen;
	}

	auto value = (LPWSTR)ExAllocatePoolWithTag(PagedPool, buflen, USBIP_VHCI_POOL_TAG);
	if (!value) {
		Trace(TRACE_LEVEL_ERROR, "Can't allocate %lu bytes of memory", buflen);
		return nullptr;
	}

	status = IoGetDeviceProperty(pdo, prop, buflen, value, &buflen);
	if (NT_ERROR(status)) {
		Trace(TRACE_LEVEL_ERROR, "IoGetDeviceProperty %!STATUS!", status);
		ExFreePoolWithTag(value, USBIP_VHCI_POOL_TAG);
		return nullptr;
	}

	return value;
}

PAGEABLE PDEVICE_OBJECT vdev_create(DRIVER_OBJECT *drvobj, vdev_type_t type)
{
	PAGED_CODE();

	DEVICE_OBJECT *devobj{};
	auto extsize = ext_sizes_per_devtype[type];
	NTSTATUS status{};

	switch (type) {
	case VDEV_CPDO:
	case VDEV_HPDO:
	case VDEV_VPDO:
		status = IoCreateDeviceSecure(drvobj, extsize, nullptr,
				FILE_DEVICE_BUS_EXTENDER, FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
				FALSE, &SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RWX_RES_RWX, // allow normal users to access the devices
				&GUID_SD_USBIP_VHCI, &devobj);
		break;
	default:
		status = IoCreateDevice(drvobj, extsize, nullptr,
					FILE_DEVICE_BUS_EXTENDER, FILE_DEVICE_SECURE_OPEN, TRUE, &devobj);
	}

	if (!NT_SUCCESS(status)) {
		Trace(TRACE_LEVEL_ERROR, "Failed to create vdev(%!vdev_type_t!): %!STATUS!", type, status);
		return nullptr;
	}

	auto vdev = to_vdev(devobj);

	vdev->PnPState = pnp_state::NotStarted;
	vdev->PreviousPnPState = pnp_state::NotStarted;

	vdev->type = type;
	vdev->Self = devobj;

	vdev->DevicePowerState = PowerDeviceUnspecified;
	vdev->SystemPowerState = PowerSystemWorking;

	devobj->Flags |= DO_POWER_PAGABLE | DO_BUFFERED_IO;

	return devobj;
}

cpdo_dev_t *to_cpdo_or_null(DEVICE_OBJECT *devobj)
{
	auto vdev = to_vdev(devobj);
	NT_ASSERT(vdev);
	return vdev->type == VDEV_CPDO ? static_cast<cpdo_dev_t*>(vdev) : nullptr;
}

vhci_dev_t *to_vhci_or_null(DEVICE_OBJECT *devobj)
{
	auto vdev = to_vdev(devobj);
	NT_ASSERT(vdev);
	return vdev->type == VDEV_VHCI ? static_cast<vhci_dev_t*>(vdev) : nullptr;
}

hpdo_dev_t *to_hpdo_or_null(DEVICE_OBJECT *devobj)
{
	auto vdev = to_vdev(devobj);
	NT_ASSERT(vdev);
	return vdev->type == VDEV_HPDO ? static_cast<hpdo_dev_t*>(vdev) : nullptr;
}

vhub_dev_t *to_vhub_or_null(DEVICE_OBJECT *devobj)
{
	auto vdev = to_vdev(devobj);
	NT_ASSERT(vdev);
	return vdev->type == VDEV_VHUB ? static_cast<vhub_dev_t*>(vdev) : nullptr;
}

vpdo_dev_t *to_vpdo_or_null(DEVICE_OBJECT *devobj)
{
	auto vdev = to_vdev(devobj);
	NT_ASSERT(vdev);
	return vdev->type == VDEV_VPDO ? static_cast<vpdo_dev_t*>(vdev) : nullptr;
}
